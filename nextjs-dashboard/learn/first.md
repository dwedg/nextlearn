1. Server Components适用场景：
    + ✅ 初始页面渲染（SEO 关键内容）
    + ✅ 静态/低频更新数据（如博客文章、产品详情）
    + ✅ 敏感数据获取（直连数据库不暴露 API）
    + ✅ 减少客户端 JS 体积（提升加载速度

-----
2. Client Components 最适合：
+ ✅ 交互式 UI（表单、动画、拖拽）
+ ✅ 实时状态更新（计数器、购物车）
+ ✅ 浏览器 API（useEffect、localStorage）
+ ✅ 第三方库（依赖 useState 的图表/地图库）

-----
3. 使用建议：
   + 80% 静态内容：用 Server Components 最大化性能
   + 20% 交互部件：用 Client Components 保持灵活性
   + 混合渲染：通过 Props 将服务端数据传递给客户端组件
   + 更新策略：根据场景选择 revalidate、Server Actions 或客户端状态

-----
4. 请求瀑布：指多个请求依赖前一个请求的结果，导致必须顺序等待，降低性能；
-----
5. 静态渲染:页面在构建时生成静态HTML,数据不会实时更新，除非手动触发重建。

------
6.在动态渲染中，内容是在用户访问页面时实时在服务器上渲染的（即请求发生时渲染）。动态渲染有以下几个优点：
+ ✅ 实时数据，动态渲染允许你的应用显示实时或频繁更新的数据，非常适合数据经常变化的应用场景。
+ ✅ 用户特定的内容，更容易为用户提供个性化内容，例如仪表盘（dashboard）或用户个人主页，并且可以根据用户的交互动态更新数据。
+ ✅ 请求时可用的信息，动态渲染可以访问只有在请求时才能获取的信息，例如 cookies 或 URL 的查询参数（search parameters）。

-----
7. 流式渲染（Streaming） 非常契合 React 的组件模型，因为每个组件都可以看作是一个“渲染块（chunk）”。先显示可用部分，慢的部分后加载.在 Next.js 中，有两种实现流式渲染的方式：
+ 页面级别：使用 loading.tsx 文件（Next.js 会自动为页面生成 `<Suspense>` 包裹）。
+ 组件级别：直接使用 `<Suspense>` 来实现更细粒度的控制。

------
8. 如果loading.tsx文件所在文件系统的层级比子页面高，那么它也能应用在子页面的加载上。

-----
9. 路由分组（Route Groups） 允许你将文件按照逻辑进行组织，而不会影响 URL 路径结构。当你使用括号 () 创建一个新文件夹时，这个文件夹的名称不会出现在 URL 路径中。例如：/dashboard/(overview)/page.tsx 的访问路径仍然是 /dashboard。

比如在某种情况下，希望子页面有各自的loading,那么就可以创建一个（）文件目录，将loading放入这个文件夹中，这样就不会影响父组件下其他路径子组件的loading

----
10.Nextjs中自带的loading.tsx
+ 它是基于react的Suspense实现的。
+ 使用这个组件的页面，在动态组件加载期间，用loading组件过渡，静态组件可以立即显示，依然可以与用户进行交互，比如导航组件。
+ 所以用户不需要等待页面加载完成就可以跳转到其他页面。这种机制叫做可中断导航。
+ 常用骨架屏作为加载组件。

-----
11.使用Suspense的场景，Suspense的使用方法视情况而定，通常最好的做法是将数据请求下沉到真正需要它的组件中，并用Suspense包裹这些组件。如果你的应用场景需要，也完全可以包裹整页或大区域来实现统一加载体验。
+ 希望体验页面流式加载的过程
+ 需要优先展示一些内容，比如加载期间过渡的骨架屏
+ 有些依赖于数据获取的组件

----
12.部分渲染（partial Prerendering简称PPR） 是一种混合渲染策略，它将页面中的静态内容和动态内筒混合渲染。它允许像Next.js这样的React框架在构建阶段渲染页面的静态部分，而将动态部分推迟到用户访问页面时再加载。它的工作机制：
+ 在构建时，静态内容会直接被渲染为html内容，被React.Suspense包裹的动态内容会用fallback UI(例如加载动画)代替，最终形成一个包含静态内容和fallback的静态壳。
+ 在运行时（用户访问页面时）当动态数据准备好后（例如API响应，用户认证信息）Suspense边界会恢复渲染，将fallback替换为真实内容。

⚠️注意：被 Suspense 包裹的组件 必须支持 Suspense，这通常要求使用 React.lazy() 或在 Next.js 中使用异步的服务端组件（Server Components）。仅仅用 Suspense 包裹组件 不会让它变成动态的，组件本身需要发起数据请求或异步操作。fallback 的设计要尽量保持良好的用户体验。

---
13.回顾到目前为止已经完成一些优化应用中数据请求的工作：
+ 将数据库部署在与你的应用代码相同的区域，以减少服务器与数据库之间的延迟。

+ 使用 React 服务器组件（React Server Components）在服务端获取数据。这样可以将耗时的数据请求和逻辑保留在服务器端，减少客户端 JavaScript 的体积，并防止数据库密钥暴露给客户端。

+ 使用 SQL 精确获取所需的数据，减少了每次请求传输的数据量，也减少了内存中进行数据转换所需的 JavaScript 代码量。

+ 在合适的场景下，使用 JavaScript 并行请求数据，提高了性能。

+ 实现了流式渲染（Streaming），避免了某些较慢的数据请求阻塞整个页面的渲染，使用户可以在所有内容加载完成前就开始与 UI 交互。

+ 将数据请求逻辑下移到真正需要它的组件中，从而明确了哪些路由部分是动态的。

-----
14. 实现基于 URL 参数的搜索有几个好处：
+ 可收藏和可分享的URL:由于搜索参数包含在URL中，用户可以收藏当前应用的状态（包括搜索关键词和筛选条件），以便将来查看或分享给他人。用户可以把这个 URL 加入浏览器书签（收藏夹）。下次再点击这个收藏，页面会自动恢复到之前的搜索结果和筛选状态，无需重新输入。用户可以复制这个 URL 发给别人（朋友、同事、客户等）。接收者点击这个链接后，会看到相同的搜索结果页面，无需额外操作。
+ 服务端渲染支持：URL参数可以直接在服务端读取，从而用于渲染页面的初始状态，这让服务器渲染变得更加简单。服务器会在接收到浏览器请求时，根据请求信息生成完整的 HTML 页面，然后把这个页面发送给浏览器。用户无需等待 JS 加载和执行，就能看到完整内容。
```text
#当用户访问一个带有 URL 查询参数的页面，比如：
https://example.com/search?keyword=laptop&sort=price-desc

```
这些参数 keyword=laptop 和 sort=price-desc 会随着 HTTP 请求一起发送到服务器。这时，服务器就可以：a.直接读取这些参数。b.根据参数去查询数据库或 API。c.生成包含搜索结果的 HTML 页面。d.返回给用户浏览器。
+ 便于分析和追踪：将搜索关键词和筛选条件直接暴露在URL中，可以更加方便追踪用户行为，无需额外的客户端逻辑支持。在实际应用中，开发者或产品人员通常希望知道：用户在搜索什么？用户最常用的筛选条件有哪些？这些数据对产品优化、推荐系统、运营策略等都非常重要。