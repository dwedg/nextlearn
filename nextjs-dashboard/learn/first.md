1. Server Components适用场景：
    + ✅ 初始页面渲染（SEO 关键内容）
    + ✅ 静态/低频更新数据（如博客文章、产品详情）
    + ✅ 敏感数据获取（直连数据库不暴露 API）
    + ✅ 减少客户端 JS 体积（提升加载速度

-----
2. Client Components 最适合：
+ ✅ 交互式 UI（表单、动画、拖拽）
+ ✅ 实时状态更新（计数器、购物车）
+ ✅ 浏览器 API（useEffect、localStorage）
+ ✅ 第三方库（依赖 useState 的图表/地图库）

-----
3. 使用建议：
   + 80% 静态内容：用 Server Components 最大化性能
   + 20% 交互部件：用 Client Components 保持灵活性
   + 混合渲染：通过 Props 将服务端数据传递给客户端组件
   + 更新策略：根据场景选择 revalidate、Server Actions 或客户端状态

-----
4. 请求瀑布：指多个请求依赖前一个请求的结果，导致必须顺序等待，降低性能；
-----
5. 静态渲染:页面在构建时生成静态HTML,数据不会实时更新，除非手动触发重建。

------
6.在动态渲染中，内容是在用户访问页面时实时在服务器上渲染的（即请求发生时渲染）。动态渲染有以下几个优点：
+ ✅ 实时数据，动态渲染允许你的应用显示实时或频繁更新的数据，非常适合数据经常变化的应用场景。
+ ✅ 用户特定的内容，更容易为用户提供个性化内容，例如仪表盘（dashboard）或用户个人主页，并且可以根据用户的交互动态更新数据。
+ ✅ 请求时可用的信息，动态渲染可以访问只有在请求时才能获取的信息，例如 cookies 或 URL 的查询参数（search parameters）。

-----
7. 流式渲染（Streaming） 非常契合 React 的组件模型，因为每个组件都可以看作是一个“渲染块（chunk）”。先显示可用部分，慢的部分后加载.在 Next.js 中，有两种实现流式渲染的方式：
+ 页面级别：使用 loading.tsx 文件（Next.js 会自动为页面生成 `<Suspense>` 包裹）。
+ 组件级别：直接使用 `<Suspense>` 来实现更细粒度的控制。

------
8. 如果loading.tsx文件所在文件系统的层级比子页面高，那么它也能应用在子页面的加载上。

-----
9. 路由分组（Route Groups） 允许你将文件按照逻辑进行组织，而不会影响 URL 路径结构。当你使用括号 () 创建一个新文件夹时，这个文件夹的名称不会出现在 URL 路径中。例如：/dashboard/(overview)/page.tsx 的访问路径仍然是 /dashboard。

比如在某种情况下，希望子页面有各自的loading,那么就可以创建一个（）文件目录，将loading放入这个文件夹中，这样就不会影响父组件下其他路径子组件的loading